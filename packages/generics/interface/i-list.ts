export interface IList<T> {
    [position: number]: T;
    add(entity: T);
    addRange(entities: T[]);
    all(predicate: (value?: T, index?: number, list?: T[]) => boolean): boolean;
    any(predicate: (value?: T, index?: number, list?: T[]) => boolean): boolean;
    average(transform?: (value?: T, index?: number, list?: T[]) => any): number;
    contains(element: T): boolean;
    count(predicate?: (value?: T, index?: number, list?: T[]) => boolean): number;
    where(predicate: (value?: T, index?: number, list?: T[]) => boolean): IList<T>;
    distinct(): IList<T>;
    distinctBy(keySelector: (key: T) => string | number): IList<T>;
    elementAt(index: number): T;
    first(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    firstOrDefault(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
    aggregate<U>(accumulator: (accum: U, value?: T, index?: number, list?: T[]) => any, initialValue?: U): any;
    groupBy(grouper: (key: T) => any, mapper: (element: T) => any): any;
    insert(index: number, element: T): void | Error;
    last(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    lastOrDefault(predicate?: (value?: T, index?: number, list?: T[]) => boolean): T | Error;
    max(): number;
    max(predicate: (value: T, index: number, list: T[]) => number): number;
    max(predicate?: (value: T, index: number, list: T[]) => number): number;
    maxBy(keySelector: (key: T) => number): T;
    min(): number;
    min(predicate: (value: T, index: number, list: T[]) => number): number;
    min(predicate?: (value: T, index: number, list: T[]) => number): number;
    minBy(keySelector: (key: T) => number): T;
    orderBy(predicate: (key: T) => any): IList<T>;
    orderByDescending(predicate: (key: T) => any): IList<T>;
    remove(element: T): boolean;
    removeAll(predicate: (value?: T, index?: number, list?: T[]) => boolean): IList<T>;
    removeAt(index: number): void;
    select(mapper: (value?: T, index?: number, list?: T[]) => any): any;
    single(): T | Error;
    singleOrDefault(): T | Error;
    skip(amount: number): T[];
    sum(transform?: (value?: T, index?: number, list?: T[]) => number): number;
    take(amount: number): IList<T>;
}